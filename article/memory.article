go memmory management and model

AbbyNie

2020-04-22

* 进程的内存模型

- code text:代码的在内存中保存的位置

- 静态全局(已初始化的静态全局变量和未初始化的静态全局变量):全局共享变量数据存储的位置

- stack:函数栈变量数据存储位置

- heap:不确定长度或在不同函数栈之间共享的数据存储位置

.image ./1.jpg _ 150

* 多线程的内存模型

- 同一进程的线程间共享的数据

  1.源代码
  2.全局变量
  3.操作系统资源(如打开的文件等)
.image ./mutithreads.png _ 300

- 每个线程都会分配一个堆栈来保存线程中的数据

** stack

- stack在函数调用时创建strack fram来保存函数内的数据，调用方的寄存器和返回地址

- stack fram的内存结构

.image ./2.PNG _ 200

** stack是如何分配的

- 函数开始执行时创建strak fram来保存局部变量数据

- 保存调用函数的寄存器状态

- 保存调用函数的地址

- stack中的内存是确定

** heap是如何分配的

- heap的内存是在运行时确定

** stack和heap的区别

- stack中的内存是确定的，heap中的内存是在运行时分配的

- stack中的内存是在函数结束时自动回收，heap中的内存需要手动释放或垃圾回收,时间复杂度比stack的自动内存回收更复杂

- stack中的变量在赋值或传参数时是开辟新的内存复制原来变量的值，heap是通过指针传递共享数据。所以heap适合需要的变量使用的内存比较大时的分配

*** c语言中heap的分配方式

- 使用new函数申请对内存的分配

- 使用free释放内存

*** c语言中c的分配方式缺陷

- 使用new申请的内存并不一定真正需要在内存中分配

- 用户可能会忘记free释放内存而导致内存泄漏

*** go中heap的分配方式

- go中的heap内存分配是由编译器在编译时通过逃逸分析决定的

- 逃逸分析由三种情况决定是否需要将变量的内存分配在堆上

  1.变成需要的内存非常大
  2.变量需要的内存在不能确定
  3.在函数结束时返回了变量的地址

*** go中heap分配的优势

- 尽可能将变量分配在栈上，减少垃圾回收次数

- 用户不用关心变量分配在栈上还是堆上

*** heap内存分配与进程性能的关系

- heap中的内存回收需要垃圾回收机制，比栈上自动回收更复杂和耗时，所以要尽量减小提高程序执行的速度

** 如何思考一个变量的声明
   变量如何使用------》变量的类型------》变量的名称，变量的周期-------》变量的内存分配情况--------》如果变量分配在堆中如何使用变量能减少垃圾回收次数

** 在程序开发过程中如何关注和分析进程的内存，分别可以利用什么工具进行

- 由于过早的优化是万恶之源，所以开始开发时要更关注更好的实现业务层，但是对于自己写的代码内存使用情况要了解，并利用各种程序性能检测工具检测出一场情况时进程性能优化，这样才能在合适的时机快速debug出程序的问题

- 开始过程中
  1.关注变量的如何使用，使用合适的类型
  2.关注变量的内存分配情况，是分配在栈中更合理还是分配在堆中更合理。分配在堆中如何使用malloc合理的给变量申请内存减少变量重新分配内存导致的垃圾回收和数据移动复制
  3.使用go test benchmark测试性能，了解函数执行时间，CPU使用情况，内存使用情况和垃圾回收次数
    go test -bench=. -benchmem

- 整体查看程序各个资源使用情况工具

  1.cpu使用情况htop
  2.I/O使用情况iotop
  3.memory使用情况 htop，free
  4.time查看程序运行时间，用户模式下代码执行使用的时间和内核模式下代码使用的时间

- debug程序各部分性能找出有问题的地方
  
  1.使用pprof支持对程序CPU，memory，threadcreate，goroutine，block，mutex各种资源使用情况的具体分析，并且可以使用go tool pprof查看分析文件，使用它可以找出程序性能瓶颈的具体地方
    GraphViz还支持图形显示

  2.

** 操作系统如何给进程分配内存

** go中内存的分配和管理

** go为什么要自己实现内存分配管理机制
