go语言基础
2019-11-28
Tags: go, kownledge base

Abby Nie

* 程序结构

go语言的程序通过小的基本组件构建而来，

小的基本组件：

  变量、常量、类型和函数几种基本结构，

  由基础数据类型通过数组和结构体聚合；

  使用 if、for、switch等控制语句控制程序执行流程；

  由语句组成函数隔离和复用；

  函数组织成源文件，

  源文件再组织成包来支持模块化；

* 命名

go语言命名的基本规则

- 包名都是小写
- 使用驼峰式命名法
- 仅首字母大写的是可导出的
- 变量或常量的作用域越大，使用越长且越有意义的名称，作用域小的局部变量尽量使用短名称
- 函数命名简短清晰

* 如何做有意义的命名

什么是有意的命名：有意义的名称能告诉你它为什么存在，有什么用和如何使用

- 命名要做有意义的区分，不要使用a1、a2这类没意义的名称，或者Info、Data这种含义很泛的名称
- 养成统一的命名风格，不要使用相近的不同单词来命名同种方法，如fetch、retrieve、get等
- 类名使用名词，方法名使用动词或动词短语
- 使用有意义的语境，并结合上下文命名

* 声明 ( 1 )

go中的声明和格式
变量:

  var 名称 类型

  名称 := 值（短声明）

常量:

  const 名称 类型

类型

  type 名称 类型

  type 名称 struct{
    属性名称 类型
  }

* 声明  ( 2 )

函数

  func 函数名称(参数名称 类型) 返回值类型

包声明

  package 包名称

导入包声明

  import 导入包的路径


* 变量

变量的定义：

  存储指定类型的值，将值与相对应的符号名称绑定，且变量运行时能够改变。

变量的声明

  var name type = expression

- 变量的声明声明了变量的名称、类型和初始化了初始值

- 变量的类型或初始化表达式可以省略，如果省略初始值变量将初始化为对应类型的零值；如果省略了类型，变量的类型将由初始化表达式决定

  name := expression

  短变量声明只适用于局部范围内变量的声明，使用这种形式的声明就说明变量只在局部范围内可用，不会共享给其他地方使用

* 各种类型对应的零值

  数字类型是0

  布尔类型是false

  strings类型行是""

  接口和引用类型是nil

  像数组或者结构体这种聚合类型默认初始值是成员的的零值

go中变量默认初始化作用：

  默认初始化保证了变量在任何时刻都至少有一个零值，减少了程序在运行时因为程序没有值而导致的空地址崩溃问题

  go中提倡对复杂类型变量进行有意义的初始化,使变量在生命周期开始时就是可用的

  java中没有默认初始化机制，如果变量没有默认初始化就会报错

变量的作用:

  系统分配内存给变量存储变量值

  变量通过名称区分了不同的变量

  go函数中参数变量的传递都是值传递

使用变量时的关注点

  变量的类型

  变量的使用范围（作用域）

  变量是否需要共享

* 代码

.code ../initvalue/main.go /START OMIT/,/END OMIT/

* 指针

什么是指针:

  指针的值保存了变量的地址

指针的作用

  通过指针我们不需要知道变量的地址就可以读取和更新变量的值

指针声明格式

  var name *Type = expression

赋值和更新变量的值

  var x int = 125
  var p *int
  var p = &x
  *p = 2

  指针p的类型为*int类型
  通过&x获得了变量x的地址赋值给了指针p
  *p代表变量的值，通过*p=expression更新了变量的值

* code
.code ../pointer/main.go /^func main/,/^}/

* code
.code ../pointer/main.go /START OMIT/,/END OMIT/

 函数返回变量地址时，在函数运行结束后变量仍然存在
 通过在函数中传递指针参数，在函数中可以直接更新指针所指向变量的值
 指针在内存中的形式:

.image ./pointer.png

* 指针有什么用

 使用指针只需要保存变量的地址就可以修改变量或获取变量的值

 指针能减少变量的内存分配

 通过传递指针类型参数使变量的修改可以再多个函数之间共享

什么时候用指针类型

 当函数对变量的修改对其他函数可见时，使用指针类型

 当变量需要的内存很大时，使用指针类型修改或获取变量的值可以减少内存复制

* c语言中的指针运算
  在c语言中指针变量可以进行+、-、比较运算

  指针p+n表示将指针向后偏移指针所指向数据n个元素后得到的元素首地址

  指针p-n表示将指针向前偏移指针所指向数据n个元素后得到的元素首地址

  指针p<q表示指针p保存的地址位置在q的前面，指针p>q表示指针p保存的地址在q的后面,指针p==q表示p与q指向同一个变量

指针运算的作用：

  指针运算能提高程序获取或修该变量的的速度，提高程序的执行效率

* 什么是内存对齐:

内存对齐有什么用:

如何内存对齐:

go中结构体是如何对齐的：

  在64位系统中可以对齐的位数有1字节、2字节、4字节、8字节

  结构体对齐到占用内存最大的成员大小，但最大对齐到8字节

  结构体成员的起始地址要对齐到成员本身大小

  复杂类型成员对齐到机器字大小

* code
.play ../aligin/main.go
* unsafe包


* new Function
  p := new(int)
  new(T)创建了匿名类型为T的变量，初始化匿名变量的值为对应类型零值，并且把它的地址返回
.code ../new/main.go

* 变量的赋值
赋值的格式

.code ../assignment/main.go /START OMIT/,/END OMIT/

* 可赋值性

什么是可赋值的

- 在=左侧变量的类型与右侧赋值表达式的类型相同时一定是可以赋值的

- 赋值语句两侧的类型必须精确匹配

- nil可以赋值给任何接口或引用类型

- 进行== 或!=等运算符进行比较时比较运算两侧的操作数必须是可赋值的

* 变量的生命周期

变量生命周期定义：

  在程序运行过程中变量存在的时间

如何判定变量的生命周期

- 包级别变量的生命周期是整个程序运行时间

- 局部变量的生命周期是动态的，从声明时开始创建，直到不可访问时结束，并且变量占用的内存会被回收

- 函数中的参数和返回值也是局部变量，在其闭包函数被调用时创建,函数结束时如果没有外部引用时结束

* code
.code ../lifetime/main.go /^func main/,/^}/

* code
.code ../lifetime/main.go /START OMIT/,/END OMIT/


* 什么是栈内存

  是一种在函数执行时创建的后进先出的内存结构

  由CPU在编译时管理这种内存的分配

  在函数执行完之后由CPU自动回收

什么是堆内存

  是一种在运行时动态分配的内存

  手动申请和释放或者由垃圾回收器回收

* 栈内存与堆内存的区别

- 栈内存的的分配与回收都是由CPU自动管理，不需要手动管理；堆内存的分配需要手动管理回收或使用垃圾回收器回收

- 垃圾回收器要比较耗时，所以栈内存的创建和回收的执行效率比堆要高很多

- 栈内存分配的大小有限制，超过限制大小的内存都分配在堆上

- 在堆上创建的指针变量可以在程序任何地方访问

* go中如何确定变量的内存分配在堆上还是栈上


   首先go在编译时尽量将函数中的变量分配在栈上

   然后通过逃逸分析来分析分析变量是否需要分配在堆上

   逃逸分析是通过变量的引用情况和变量的内存大小来分析变量内存分配

* go语言中内存分配的优势

 go中的内存分配是编译器通过逃逸分析决定的，不需要用户关心是如何分配的；在c语言中需要是通过malloc() or calloc()手动申请堆内存，使用free()函数释放内存。

 go中通过多种方式最大程度的减少了内存分配在堆上的可能性，最大程度的提高了内存分配效率。

 第一种方式：除了map、slice、channel这几种引用类型类型、字符串、指针指向的变量可能分配在堆上，其他变量一般都是分配在栈上

 第二种方式：可能分配在堆上的变量也是通过逃逸分析决定是否分配在堆上，只有发生了逃逸的变量才能分配在堆上，不像很多其他语言是通过关键自决定的。

 go中的逃逸分析是在编译时进行了，不像Java是在运行时进行的,提高了程序执行效率

go中变量内存分配的分析方法

  go build -gcflags='-m -m' main.go 或者 go build -gcflags='-m -l' main.go

* go中是如何进行逃逸分析的

-  什么是逃逸分析：编译器决定变量存储位置的过程
-  当函数结束之后变量的地址被return返回了
-  变量申请的栈空间过大导致逃逸
-  变量的需要的内存不确定时
-  在函数结束时变量仍被别的函数使用

* code
.code ../memory/main.go /^func main/,/^}/

* code
.code ../memory/main.go /START OMIT/,/END OMIT/

* 为什么要进行逃逸分析

- 进行逃逸分析最大程度的减少了变量内存在堆中的分配，降低了垃圾回收的次数，提高了程序执行效率

- 同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行

理解内存分配有什么用

  了解程序中变量的内存是分配在堆还是栈中，在堆中的变量何时回收，

  优化程序，减少堆变量或堆变量的回收次数，提高程序执行效率

* code(1)

.code ../join/main.go /^func Join/,/^}/

 Join函数中的sep + slice[i] 大小不确定，会被分配到堆内存中

 由于为string是只读的，不能修改，所以每次s += sep + slice[i]赋值s之后之前的sep + slice[i]就会回收

 造成了i-1次垃圾回收和堆内存分配

* 性能测试代码(1)

.code ../join/main_test.go /^func BenchmarkJoin/,/^}/

* code(2)

.code ../join/main.go /^func FastJoin/,/^}/

 FastJoin使用[]byte类型保存连接的字符，只有在函数结束之后才会被回收，所以只有一次垃圾回收,提高了效率

* 性能测试代码(2)

.code ../join/main_test.go /^func BenchmarkFastJoin/,/^}/

* 性能分析结果

.image join.png _ 1000

* 常量

什么是常量：

  常量是确定值之后就不能改变的，常量的值是在编译时确定

  常量的值一般是基本数据类型

常量的声明

  const name Type = expression

  类型可以省略,如果省略就是无类型常量

  常量只能通过字面量或内置的len、cap、real等函数赋值

  常量的逻辑、算数、比较运算的结果也是常量

常量与变量的区别

  常量的值在编译时就确定了且运行时不会发生改变

  常量的值必须在编译时确定，所以不能使用自定义函数给常量赋值，但是可以使用go内置函数len、cap、real等给常量赋值

* iota常量生成器

  iota:给一组有相似规则的常量赋值，iota的值从0开始，然后每一个声明的常量行加一

无类型常量：

  常量声明时没有指明类型，且通过数字字面量赋值，类型是无类型的常量

  常量通过推迟这种常量的类型确定提高了常量运算精度和值范围

* 类型

什么是类型：

  变量的类型描述了对应值拥有的属性特征,如占用的内存大小、具有的操作和运算、具有的属性和行为方法

  通过类型严格限定了对应类型变量拥有的行为和属性特征

类型的作用

  类型是程序设计者对程序以较高层次的方式思考，抽象化事物的特征。

  由于类型的存在，编译器能检查对应类型变量使用的行为和属性是否合法

  通过类型定义了变量的作用，提高了代码的可读性


类型声明格式：

  type name Type(基础类型)

  重新定义以Type类型为基础类类型的类型的真正含义

  基础类型相同的类型之间可以类型转换

* code
.code ../type/main.go

* 作用域

作用域：

  指变量或常量的可以使用的范围,是编译时的概念

作用域作用

  通过作用域限定变量的使用范围，使得变量不会被其他范围使用，保护了变量的安全

作用域的范围有哪些

  包级别作用域、局部范围作用域、文件级别作用域

  包级别作用域的变量在包内任何地方都可使用和修改，所以使用起来不安全，尽量不使用

  局部范围作用域只在局部范围可用，通过范围限定保证了变量的安全，是范围之外不可用，保证了变量的安全性

  通过import导入的包只在导入文件内可用


如何判断代码的作用域

  go内部声明的函数做作用域是整个程序都可见

  包级别的声明作用域是整个包

  导入的包作用域是导入的文件

  函数内声明的包作用域是整个函数

  for、if、switch词法块内声明的包作用域是整个词法块

* 垃圾回收器如何确定何时回收变量

什么是垃圾回收：

  一种管理动态内存的机制，负责追踪堆内存的申请、回收不再使用的堆内存和保护正在使用的堆内存。

go gc的实现原理
go gc的优势
go 程序性能的调优

* 基本数据类型
go中的数据类型：

  基础数据类型、聚合类型、引用类型、接口类型

基础数据类型：

  整数、浮点数、复数、布尔值和字符串

* 整数

整数的类型：

  无符号整数和有符号整数

无符号整数类型：

  无符号类型有uint8、uint16、uint32、uint64、uint和uintptr

  无符号类型的范围是0到2的n次方−1

  byte类型是uint8的别名

  uint的大小与平台相关，不是是32位就是64位，但是具体大小有平台决定

  uintptr是用来存放指针值值得类型，大小与平台有关

* 有符号整数类型

  有符号整数类型有int8、int16、int32、int64和int

  有符号整数的范围是-2的n-1次方到2的n-1次方-1

  rune类型是int32的别名，指明值是Unicode码点的值

  int类型的大小与平台有关，不是32位就是64位，具体有平台决定

* code
.code ../integer/main.go /START MIT/,/END MIT/

* 运行得出范围值结果
.image integer.png _ 1000

* 有符号整数是如何存储的

  有符号整数采用补码的形式存储在计算机中

  最高位为符号位

什么是补码

  正数的补码等于原码；负数的补码等于反码加1，而反码等于原码符号位不变，其余各位取反

有符号整数为什么要采用补码形式存储

  简化计算机基本运算电路，使加减法都只需要用加法电路实现，用加法替代减法。

  简化计算机的运算

* code
.code ../int/main.go /^func main/,/}/

* 无符号整数与有符号整数的去别，分别适合在什么场合下使用

  无符号整数类型只能表示非负数

  同样位数的无符号数表示的整数范围比有符号整数大很多

  通常情况下大多使用有符号整数类型变量来存储整数值

  无符号类型往往只用于位运算和特定算数运算，如实现位集，解析出二进制格式的文件，或散列和加密

* 整数支持的运算

  整数可以进行算数运算、逻辑运算和比较运算

  进行运算时变量的类型必须相同，否则要进行显示类型转换才能在不同类型中进行运算操作

  位数大的类型像位数小的类型转换可能会发生溢出

  运算的结果类型与运算的变量类型相同

  运算结果超出了类型的范围会发生溢出，溢出时高出位部分会被丢弃

整数支持的算数运算
 
  + - * / %

  / 操作数都为整型运算得到结果是整数类型

  % 操作只能用于整数类型

  运算的结果类型与操作的变量类型相同

* code
.code ../arithmetic/main.go /func main/,/}/

* 逻辑运算

  & |  ^ &^ << >>

  ^ 用于一元运算时表示按位取反，用于二元运算时表示按位异或

  x &^ y 是按位清空，如果y上的值是0则取x对应位上的值，如果y上bit位的值为1结果位上取0

  x<<n 或 x>>n 移位运算中n必须无符号类型

  算数上x >> n结果是x除以2的n次方向下取整，x << n结果是x乘以2^n

  无符号移位都是用0填补空位

  有符号整数右移是用符号位填补空位

  有符号位左移是用0填补空位

  运算的结果类型与操作的变量类型相同

* code

.play ../logicoper/main.go

* 逻辑运算

  == != < <= > >=

  比较表达式的结果类型是布尔型

类型转换

  使用T(x)可以将x转换成T类型

  整型与整型的类型转换大部分不会发生值得变化，只是告诉编译器如何解读值

  当缩减大小的整型转换或浮点数转换会发生值得改变或精度损失


* 浮点数

  go中支持float32和float64两种类型浮点数

  float32支持的精度大约是6位

  float64支持的精度大约是15位

  因为float64能表示的范围更大，精确度更高，一般情况使用float64类型保存浮点数更多

* code
.play ../float/main.go

* 布尔值

  布尔型的值只有两种可能：真（true)和假（false）

  预算符&&或者||的运算结果是布尔类型

  比较运算的运算结果是布尔类型

* 字符串

  字符串定义：不可变字节序列

  字符串的内存结构

.image strmemory.png _ 300

  有一个保存了底层数据首字符位置的指针和保存字符占用的字节长度结构组成

  底层保存字符值的是[]byte类型保存字符值

* 字符的操作：

  s := "hello,world"

  len(s)返回字符串s的字节数

  s[i]返回第i个字节对应的字符值

  生成字符串的子串操作s[i:j]，s[i:j]返回s从i开始知道j位置的字符串值，s[i:]返回从i开始直到结尾的字符串，s[:j]返回开始直到j的字符串

  虽然可以把新值赋予字符串变量，但是字符串值本身包含的字节序列是始终不会发生改变的，所以s[i],s[i:j],s[i:]都是共用相同的底层数据

  由于字符串值本身不可变，所以可以安全的公用底层数据，使得复制字符串和生成子串都不需要新的内存，因此字符串的复制和生成子串效率都很高

  +号运算可以连接两个字符串生成新的字符串

* code

.play ../string/main.go

* 代码过程分析分析i

.image string.png _ 400

* 字符串字面量

字符串字面量:

  带双引号的字节序列，可以用来给字符串变量赋值

原生字符串字面量:

  带反引号``的字节序列，可以用来给字符串变量赋值

  原生字符串字面量转义序列不起作用，转义序列会直接当作字普通符处理

* Unicode

字符：

  各种文字和符号的总称，是符号资源信息的单位

字符集：

  字符的集合

  不同字符集支持的范围不同，例如ASCII只支持英文字符，GB18030支持中文

  Unicode字符集包含了世界所有的字符,统一了字符库

字符码：

  字符集中与字符一一对应的码点

  在字符集中有字符与码点的对应表

  在不同字符集中相同字符的码点不一定相同

  Unicode包含了所有字符，统一了字符对应的码点

  Unicode码点用go中的rune类型存储，是in32的等价类型


* 字符集编码：

  字符集编码是字符集中字符对应码点在计算机中得存储方式

  不同的字符集对应的编码方式不同

  ASCII字符集编码是ASCII编码，GB18030字符集的编码方式是GB18030编码

  Unicode字符集的编码方式有UTF-8、UTF-16、UTF-32三种

字符集、字符、字符码关系

  字符<---------字符集--------->字符码(码点)

字符、字符编码关系

  字符码<-------字符编码----->存储在计算机的序列值

* 字符集历史

ASCII

  ASCII是最早的编码集，只包含英文字符

  使用byte类型占1个字节存储编码值

  使用前一个字节前7位包含128个字符

  ASCII的缺点是只包含英文字符,不能满足后续各个国家的语言字符

GB18030

   扩展了ASCII字符集，包含了中文字符

   兼容ASCII，汉字用2个字节表示汉字

   字符集只适合中国的语言，各个国家都是类似的包含自己国家语言的扩展

   由于各个国家各自扩展字符集，导致相同字符的字符码可能不相同，编码方式不同，互相之间也不能兼容。


* Unicode

  包含了世界上所有语言的字符的字符集

  统一了字符的字符码

  统一了编码方式

  Unicode的编码方式有UTF-32,UTF-16,UTF-8三种，现在最常用的是UTF-8

* Unicode字符集编码的发展过程

UTF-32:

  统一使用int32类型4字节存储字符码的二进制值编码

UTF-32的缺点

  由于任何字符码都是使用4字节存储，非常浪费存储空间，例如英文字符码只要1字节存储.

UTF-32的优点

  由于直接存储码点的二进制值，所以编码方式简单

  由于所有字符都是4字节存储，所以遍历效率很高

  但是由于浪费存储空间，所以已经很少用了

* UTF-16

  使用不是2字节就是4字节存储编码值

  不常见的码点值大于0xFFF的字符使用4字节，否则使用2字节

UTF-16优点

  比UTF-32更节省空间

  大部分常见的字符使用2个字节就能存储

UTF-16缺点

  由于英文字符也使用2字节存储，不兼容ASCII字符集的编码，英文字符还是比ASCII编码占用更多的内存

* UTF-8编码：
  UTF-8是存储Unicode字符集码点的变长编码方式

UTF-8编码的形式

  UTF-8使用1到4字节存码点值，1个字节存储ASCII值，2到3个字节存储常用字符码点值

  高位为0代表使用一个字节存储码点值，高位110代表使用两个字节依次类推，后面每个字节以10开头


UTF-8编码的优缺点势


* []byte

[]byte定义

  byte是uin8别名，[]byte是byte类型数据的数组

  可以用来存放编码后的码点值

  是字符串的底层数据类型，可以与字符串转换

[]byte内存结构

  在go源码中slice的机构定义如下：

  type slice struct {
  array unsafe.Pointer //数组指针
  len   int //长度
  cap   int //容量
  }

* []byte与string的比较

  字符串就是高效的只读的[]byte类型

  字符串字面量保存的字符经过utf-8编码后的值，但是字符保存的就是任意字节byte数据

  字符串变量展示的是人类可读的字符

  因为字符串的值不能修改,所以每次给字符串变量赋值都需重新分配内存和回收之前分配的内存

  字符串变量值的更改比[]byte效率更低

  string可以比较，[]byte不行

  因为字符串值不能改变，共享字符串是安全的

[]byte如和转成string,过程怎么实现

  []byte转成string,会开辟新的内存空间,拷贝[]byte中的数据，赋值给string

  string转换成[]byte类型也要开辟新的内存保存string的值

[]byte和string分别适合在什么场合下来存储字符值

  当需要大量字符串处理时[]byte效率更高

* code

.code ../byte/main.go /func main/,/^}/

* []rune

  rune是int32的别名，[]rune是rune数组

  []rune能存储编码之后的字符串码点值

  每个rune的实际占用内存由字符编码决定,utf-8编码方时rune类型占用的大小是可变的

[]rune 与[]byte比较

  []rune能存储所有字符集的字符，[]byte只能存储大小为一个字节的英文字符

  rune类型占用的实际大小是由编码方式决定的，byte始终为一个字节

  因为byte类型只能存储英文字符，所以如果字符串中包含的英文移位字符要用[]rune类型存储

  string与[]rune的区别跟[]byte与字符串的区别是相似的

* code

.code ../rune/main.go /func main/,/^}/

* 复合数据类型

数组的定义：

  数组是由固定长度和特定元素组成的序列

  数组是由相同类型的元素组成

  在内存中分配连续的内存存储数值元素

go中数组的特点：

  go中的数组类型是数组元素的一部分，因此[5]int与[6]int是不同的类型

  使用数组传参时是复制整个数组的内容传递给参数

  可以直接使用索引和值初始化数组

  数组可以用==比较，数组中每个相同索引的成员值相同，数组相等

* 数组有什么优点：

  数组的查询和修改效率很高

数组的缺点

  go中的数组长度是固定，不能增加和删除数组中的元素

  在go中使用slice代表变长的序列，增加和删除的数据的效率很低

* 数组为什么查询修改效率很高，增删效率很低

  数组中的元素在内存中是连续存放的

  数组名存放了数组第一个元素的地址

  计算机读取数据建立在地址之上的，即给定地址就进行相关的操作

  数组下表的实际意义：相对于数组起始地址的偏移量，有如下关系：
  a[i] = *(a + i)

  假设计算机查通过地址查找内存的时间为T，则查找数组a[k]基于事实一和5可以得出数组的地址*(a+k),再通过T时间查找元素就可以了

数组适合什么场合使用：

  数组适合于保存执行查询修改操作较多，增删较少的场合

* slice
slice的定义：slice是变长序列，序列中每个元素类型相同

slice的内存结构:

  []Type类型的slice结构如下：

  type Slice{
    ptr *Type //ptr指向底层数组
    len int //限定了slice可以使用的数据范围，或已存储数据的范围
    cap int //表示最大可以存储数据的大小，其实就是底层数组的长度
  }

  slice是引用类型，传值的时候传递的是slice的结构的拷贝

  slice不能进行==比较

* s[i:j]获取子序列的操作：

  s[i:j]其中0<=i<j<=cap(s)用于创建新的slice,从i开始到j-1结束，len为j-i,cap为cap(s)-i,

  i省略从0开始,j省略到len(s)-1位置

  s[i:j]与s指向相同的底层数组

  j超出len(s),意味着扩展了slice，slice长度会变大

使用make函数创建slice：

  s := make([]Type,len,cap)

  cap可以省略，省略时cap与len大小相同

  s的前len个元素会初始化为对应类型的零值

* slice中的append函数是如何工作的

  append(slice,v)

  当slice容量足够存放v时，slice[:len(slice)+1]扩充slice,给slice成员赋值slice[len]=v

  当slice没有容量存放v时，先通过make方法重新申请更大的内存给slice,用copy拷贝原来的值到slice中，添加v到slice中

* 从slice的设计结构比较slice与array TODO

slice的使用场合 TODO

* map
map的定义：散列表，拥有键值对的无序集合，键是唯一的，通过键可以查找，更新，添加，删除值，这些操作都是常量时间的键比较就可以完成。

map的使用：

  初始化：

  ages := map[string]int{"nqq":26,"hwx":46}

  ages := make(map[string]int)

  查找：

  v,ok := ages["nqq"]

  ok 为flase时key不存在在map中，获得的v值为对应类型的零值

  更新，添加：agas["nqq"] = 28

  key存在时修改对应值，不存在时添加对应key和value

  删除：delete("nqq") 删除key对应的值

* map的作用

  map中的索引key是唯一的，可以用来保存不重复的数据

  map中的索引key可以自己设置成有意义的值，列入在web缓存中设置成url值，使得能够根据key快速找到对应的值

  map中的所有操作增加，删除，修改，查询都是常量时间完成，且存储没有大小的限制

map索引的实现原理

  map的本质就是散列表

  map中的值就是存储在数组中,这个数组叫做散列表

  map的key通过散列函数映射到数组的索引，通过索引可以快速找到存放在散列表中的值

map如何自定义比较方法和使用不可比较的类型做key

  使用帮组函数，将不可比较的key转换成可比较key

哈希列表（散列表）中出现同义词（不同关键词映射到同一个位置）如何解决：

不同散列表算法比较：

* 链表

  链表的定义：

  链表是一种每个元素保存了下一个元素地址的线性表，储存数据不连续的，可以在内存任意位置

链表的操作

  增加，删除：

  链表的删除和增加只需要修改增加位置的节点，时间复杂度为O(1),所以链表做增删操作很快

  查询，修改：

  链表查询修改第n个数据需要从头节点开始查找到第n个数据才能找到第n个数据，时间复杂度为O(n),所以链表的查询很慢

链表的优缺点

  链表的增加和查询很快

  由于每个节点都会保存下一个节点的地址，所以链表不需要连续的存储空间，可以任意扩大

  链表的查询需要从头开始一个一个节点查找，所以查询很慢

链表的适用场合

  由于链表查询效率低，增删效率高，所以链表适合增删操作多，查询少的数据存储场合

* 结构体

  结构体定义：

  是一种聚合类型，由零个或多个任意类型的值聚合而成

  结构体不能包含自身类型的成员

结构体的比较：

  如果结构体的成员可以比较，结构体可以使用==或!=比较

结构体的组合：

  结构体中包含匿名的成员

  组合出的结构体不仅可以直接访问匿名成员的属性，还包含匿名成员的所有方法

* 组合与继承的比较：

  组合和继承都是代码重用的模型

  继承是单向的，当修改父类中的类的时候会影响所有的子类，所以继承的耦合度更高

  组合可以使用类任意组合，对组合中的类修改不会影响其他类，组合的耦合度更低

  继承中子类与父类的关系是child is a kind of parent,关系图如下：

.image inhertance.jpg

* 组合中类与被组合类的关系是has a的关系，如下图

.image composition.JPG _ 200

* Json

什么是Json

  用于发送和接收结构化信息的一种标准换协议

  相似的协议还有：XML，Google的Protocol Buffers

Json的作用

  用于不同平台不同端数据的交换

Json支持的类型和结构

  字符串，数字（十进制），布尔，数组，结构体

Json的操作

  编码（json.Marshal）将结构体，数组，map类型等类型编码成json格式
  解码（json.Unmarshal）将json类型解析为Go中的数据类型

*XML

什么是XML

  标记语言

XML的作用

  用于不同平台携带数据的可扩展标记语言

XML结构

  标签，元素，属性，内容

XML的作用

  富文档（Rich Documents）- 自定文件描述并使其更丰富

  元数据（Metadata）- 描述其它文件或网络资讯

  配置文档（Configuration Files）- 描述软件设置的参数

XML与Json的比较

  Json协议数据简洁，可读性强，传递的信息时轻便，数据小，只适合传递数据信息，不适合复杂的信息传递如UI信息

  XML协议的数据非常灵活，可扩展性强表达的数据有层级关系，适合复杂信息的传递，如除文本信息外，还可以对文本展示数据进行描述。html语言就是XML的一种

* 文本与HTML模版

什么是模版

  使用模版能将不同数据填充到模版中，并按模版样式展示，使得数据与格式分离

模版的功能

  选择结构体成员数据，调用函数或方法改变数据，使用表达式控制流if-else或range循环语句

模版加载数据的步骤

   分析模版文件或语句转化成内部模版结构

   基于指定的输入执行模版

go中的模版解析包

   text/template将定义模版的地方替换成输入流

   html/template与text/template功能相同，但是增加了字符串转义，避免了将输入中的带有的HTML，JavaScript,CSS与模版语法产生冲突，同时也避免了输入中带有的HTML被解析成HTML而产生的注入攻击问题

* 函数

什么是函数

   把语句序列封装再一个单元中供其他地方调用

函数的作用

  函数可以封装代码的实现，供多个地方调用

函数的申明

func name(parameter-list) (return-list) {
  body
}

go中函数的特点

  go中的函数支持多返回值，支持多返回值使得函数的返回值更清晰，灵活。在go中一般返回返回两个值，一个是期望得到的值，另一个是出错信息

  go中支持参数量可变的可变函数参数传递，经常用于格式化中

  在go中函数是第一类值，有类型，可以被赋值给其他变量，传递给函数，从函数返回

* 函数值

什么是函数值

  在go中函数是第一类值，有类型，可以被赋值给其他变量，传递给函数，从函数返回

函数值有什么作用

  函数值使得我们不仅仅可以通过数据来参数化函数，亦可通过行为来控制函数，将函数分解的更小，复用性更高

匿名函数

什么是匿名函数

  没有函数名的函数

匿名函数有什么作用

  匿名函数只会在函数内部申明和使用

  使得在函数内部声明的匿名函数可以引用函数的变量

Defered

什么是Defered函数

  在函数的所有语句执行完之后执行的函数

有什么作用

  通常用来处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁,使用defer能保证任何情况下资源都能被释放

  可以修改函数返回给调用者的返回值

* 递归

什么是递归

  函数直接或间接的调用自身

递归分析的流程

  1.基本条件（结束条件）

  2.函数实现

  3.自己条用自己

递归的缺点

  递归调用每次调用时都要在函数调用栈中分配内存给调用的函数，由于大部分编程语言使用固定大小的调用栈，所以可能导致占用的内存过大，而发生栈溢出。
  但是在go中的使用的是可变函数栈，给函数分配空间，栈的大小按需增加，所以一般不会发生栈溢出问题

  递归调用通过自己调用自己，每次调用都要在函数调用栈中分配空间给函数，所以比同样的循环实现更占用内存

* 什么是错误

  函数运行失败由预期的原因导致的，错误会返回错误的原因，在控制流程中可以处理这种错误

错误处理的策略

  1.将调用信息和参数信息添加到错误中，构造清晰的因果链返回给用户处理
  2.在有限次数内重试（使用于偶然，不可预知问题导致的错误）
  3.输出错误信息结束程序，这种情况只在main函数中处理（适用于错误发生后，程序无法继续运行）
  4.输出错误信息
  5.直接忽略掉错误

go中错误处理的优点

  go中的错误通过函数返回值就可获得，处理简单。不像Java中通过try cath获得，并且没有明确区分错误和异常

* 异常

什么是异常

  由不可预料的问题

  或程序发生了灾难性的错误导致程序的不可继续运行的问题

异常使用的场合

  发生严重的错误必须让程序退出

  问题会导致程序无法执行或执行会发生不可预期的行为

异常恢复

什么情况下应该恢复异常

  一般情况下不应该对异常恢复，要选择性的对异常恢复

如何恢复异常

  在defer函数中调用recover函数可以获得异常信息，并恢复程序

* 方法

定义：类型具有的行为，是和对象关联的函数。

方法声明

  func(name receiver)Name(input )(output){}

指针对象的方法

  当方法的接受者是指针对象时，对接受者的修改是对外可可见的。

  非指针对象修改的是接受者的拷贝

指针对象接受者使用的场合

  当接受者数据量非常大时不适合通过拷贝值传参

  对于接受者的修改希望对外不都可见时

结构体的组合

  结构体通过嵌入别的结构体而具有被嵌入结构体的功能和属性

结构体组合的作用

  通过组合可以将复杂的类型拆分成更小的类型，然后任意组合，提高代码的复用性

组合与继承的差别

  组合与被组合类型的关系史has a的关系，组合与被组合累的关系是松耦合的

  继承中子类与父类的关系是is a的关系，子类与父类的关系是紧耦合的，在Java中子类只能单继承自父类，

  所以可能形成继承链，对继承类中父类的修改会影响所有子类

方法值

  go中方法具有方法值

  方法值是将方法绑定到特定接收器变量的函数

方法值的作用

  通过方法值不需要用接收器就能可以被调用

  可以根据变量值来决定要调用哪一个类型的函数（方法）

.code ../method/main.go /func main/,/^}/

* interface

什么是接口
   
  接口是一种抽象类型，不会暴露他所代表内部值的结构和基础操作，只知道有接口中的行为
  只有当两个或两个以上的具体类型必须哟相同方式进行处理时才需要使用接口
  当接口只有一个类实现时，当实现类不能和接口存在一个相同的包中时，可以使用接口解藕两个包

使用的场合
   
  当方法的实现可能会发生改变时，可以定义出接口来让调用者使用这个方法,而不是直接使用

接口的作用

接口类型
  
  一系列方法的集合

接口值
  
  实现了接口类型中所有方法的实例的具体类型，这个类型就属于这个接口

* 接口赋值

  var w io.Writer
  w = os.Stdout(实现了接口的类型)
  var wr io.WriterReader
  w = wr (包括了w接口的wr接口)

interface{}
  
  空接口，对实现他的类型没有任何要求，可以将任意一个值赋给空接口

* 接口值
 
 接口的类型和类型的值，又分别称作接口的动态类型和动态值，接口的默认值是nil

 接口从声明到赋值的变化过程
 
.image ./interface.png _ 400

 类型断言
  
  断言的类型是一个具体的类型检查接口的动态类型是否和断言的类型匹配，返回类型值
  断言的对象是一个接口，判断类型是否满足接口，如果满足返回这个类型接口值

* goroutine

什么是goroutine
  
  go语言中实现并发执行的单元，使用关键字go加上要执行的操作就能实现并发执行操作的内容

goroutine与gorotine之间的关系

   程序启动时会创建main goroutine来执行任务，main goroutien中可以使用go关键字创建子协程并发处理任务

   goroutine与gorotine之间共享IO资源，文件和全局数据。

   goroutie有自己的函数堆栈

   main goroutine执行完任务后会直接退出不会等待子goroutie执行完，如果main gorotine退出会回收所有资源，如果有goroutien被阻塞，则这个goroutie的资源不能回收，造成goroutie泄露

   main goroutien可通过sync.WaiGorup机制或channel阻塞等待保证等待子goroutine执行完操作

goroutine的作用
    
   当有多个cpu核时能实现在多个核上并行执行任务

   并发执行需要CPU和IO等不同资源的任务，提高吞吐量

   快速与用户响应交互

goroutine的注意事项

    不同goroutien访问共享数据时的数据一致性保护

    main goroutien能等待子goroutine结束

* channel

什么是channel
    
    goroutine之间的一种通信方式

操作
    
    发送：向channel中发送消息，如果channel中满了，发送的goroutine阻塞等待

    接收：接收从channel中接收消息，如果有数据，则接收，没有则阻塞等待。如果channel关闭了可以从channel中接收零数据

    关闭：在发送端goroutine中关闭channel.不能再向channel中发送数据

有缓冲和无缓冲的channel分别有什么作用
    
    无缓冲的channel可以保证数据同步，一边发送了另一边要读取才能发送

    通过适当的设定可以消除不同协程之间的效率差距

select多路复用

    使用select选择多路复用，能接收多种channel消息，而不阻塞goroutine


使用channel控制goroutine的关闭

    当channel关闭的时候goroutine可以从channel中立即读取零值，利用这个原理通知goroutine返回结束执行

