go语言基础
2019-11-28
Tags: go, kownledge base

Abby Nie

* 程序结构

go语言的程序通过小的基本组件构建而来，

小的基本组件：

  变量、常量、类型和函数几种基本结构，

  由基础数据类型通过数组和结构体聚合；

  使用 if、for、switch等控制语句控制程序执行流程；

  由语句组成函数隔离和复用；

  函数组织成源文件，

  源文件再组织成包来支持模块化；

* 命名

go语言命名的基本规则

- 包名都是小写
- 使用驼峰式命名法
- 仅首字母大写的是可导出的
- 变量或常量的作用域越大，使用越长且越有意义的名称，作用域小的局部变量尽量使用短名称
- 函数命名简短清晰

* 如何做有意义的命名

什么是有意的命名：有意义的名称能告诉你它为什么存在，有什么用和如何使用

- 命名要做有意义的区分，不要使用a1、a2这类没意义的名称，或者Info、Data这种含义很泛的名称
- 养成统一的命名风格，不要使用相近的不同单词来命名同种方法，如fetch、retrieve、get等
- 类名使用名词，方法名使用动词或动词短语
- 使用有意义的语境，并结合上下文命名

* 声明 ( 1 )

go中的声明和格式
变量:

  var 名称 类型

  名称 := 值（短声明）

常量:

  const 名称 类型

类型

  type 名称 类型

  type 名称 struct{
    属性名称 类型
  }

* 声明  ( 2 )

函数

  func 函数名称(参数名称 类型) 返回值类型

包声明

  package 包名称

导入包声明

  import 导入包的路径


* 变量

变量的定义：

  存储指定类型的值，将值与性对应的符号名称绑定，且变量运行时能够改变。

变量的声明

  var name type = expression

- 变量的声明声明了变量的名称、类型和初始化了初始值
- 变量的类型或初始化表达式可以省略，如果省略初始值变量将初始化为对应类型的零值；如果省略了类型，变量的类型将由初始化表达式决定

  name := expression
  短变量声明只适用于局部变量，不适合于包级别变量声明，变量类型由右边表达是决定

* 各种类型对应的零值

  数字类型是0

  布尔类型是false

  strings类型行是""

  接口和引用类型是nil

  像数组或者结构体这种聚合类型默认初始值是成员的的零值

go中变量默认初始化作用：

  简化了代码

  使程序不会因为变量没有初始化造成错误或不可预测的问题

  go中提倡对复杂类型变量进行有意义的初始化,使变量在生命周期开始时就是可用的

  java中没有默认初始化机制，如果变量没有默认初始化就会报错

变量的作用:

  系统分配内存给变量存储变量值

  变量通过名称区分了不同的变量

  go函数中参数变量的传递都是值传递

* 代码

.code ../initvalue/main.go /START OMIT/,/END OMIT/

* 指针

什么是指针:
  指针的值保存了变量的地址

指针的作用

  通过指针我们不需要知道变量的名字就可以读取和更新变量的值

指针声明格式

  var name *Type = expression

赋值和更新变量的值

  var x int = 125
  var p *int
  var p = &x
  *p = 2

  指针p的类型为*int类型
  通过&x获得了变量x的地址赋值给了指针p
  *p代表变量的值，通过*p=expression更新了变量的值

* code
.code ../pointer/main.go /^func main/,/^}/

* code
.code ../pointer/main.go /START OMIT/,/END OMIT/

 函数返回变量地址时，在函数运行结束后变量仍然存在
 通过在函数中传递指针参数，在函数中可以直接更新指针所指向变量的值
 指针在内存中的形式:

.image ./pointer.png

* 指针有什么用

 由于同一个变量可以被多个指针类型引用和修改，所以指针类型可以减少变量的复制

 通过传递指针类型参数使变量可以再多个函数之间共享

什么时候用指针类型

 当函数对变量的修改对其他函数可见时，使用指针类型

 当变量需要的内存很大时，使用指针类型可以减少内存复制

* new Function
  p := new(int)
  new(T)创建了匿名类型为T的变量，初始化匿名变量的值为对应类型零值，并且把它的地址返回
.code ../new/main.go

* 变量的赋值
赋值的格式

.code ../assignment/main.go /START OMIT/,/END OMIT/

* 可赋值性

什么是可赋值的

- 在=左侧变量的类型与右侧赋值表达式的类型相同时一定是可以赋值的
- 赋值语句两侧的类型必须精确匹配
- nil可以赋值给任何接口或引用类型
- 进行== 或!=等运算符进行比较时比较运算两侧的操作数必须是可赋值的

* 变量的生命周期

什么是变量生命周期：在程序运行过程中变量存在的时间

如何判定变量的生命周期

- 全局变量的生命周期是整个程序运行时间

- 局部变量的生命周期是动态的，从声明时开始创建，直到不可访问时结束，并且变量占用的内存会被回收

- 函数中的参数和返回值也是局部变量，在其闭包函数被调用时创建,函数结束时如果没有外部引用时结束

* code
.code ../lifetime/main.go /^func main/,/^}/

* code
.code ../lifetime/main.go /START OMIT/,/END OMIT/


* 什么是栈内存

  是一种在函数执行时创建的后进先出的内存结构

  由CPU在编译时管理这种内存的分配

  在函数执行完之后由CPU自动回收

什么是堆内存

  是一种在运行时动态分配的内存

  手动申请和释放或者由垃圾回收器回收

* 栈内存与堆内存的区别

- 栈内存的的分配与回收都是由CPU自动管理，不需要手动管理；堆内存的分配需要手动管理回收或使用垃圾回收器回收

- 垃圾回收器要比较耗时，所以栈内存的创建和回收的执行效率比堆要高很多

- 栈内存分配的大小有限制，超过限制大小的内存都分配在堆上

- 在堆上创建的指针变量可以在程序任何地方访问

* go中如何确定变量的内存分配在堆上还是栈上

- go在编译时尽量将函数中的局部变量分配在栈上

- 当局部变量需要的内存很大时，变量更可能分配在堆上

- 当编译时不能确定变量需要分配内存的大小时，变量分配在堆上

- 当局部变量发生了逃逸，变量分配在堆上;如果没有发生逃逸则分配在函数的栈空间上

- 如果函数的局部变量在编译时不能确定没有被其他地方引用，则分配在堆上；否则分配在函数栈空间上

* go语言中内存分配的优势

 go中的内存分配是编译器通过逃逸分析决定的，不需要用户关心是如何分配的；在c语言中需要是通过malloc() or calloc()手动申请堆内存，使用free()函数释放内存。

 go中的内存分配都是尽量分配在栈上的，决定变量内存分配在栈上还是堆上不是由哪个关键字决定，而是使用逃逸分析分析析代码得出来的，所以内存分配和回收效率更高

go中变量内存分配的分析方法

  go build -gcflags='-m -m' main.go 或者 go build -gcflags='-m -l' main.go

* go中是如何进行逃逸分析的

-  什么是逃逸分析：编译器决定变量存储位置的过程
-  当函数结束之后变量的地址被return返回了
-  变量申请的栈空间过大导致逃逸
-  变量的需要的内存不确定时
-  在函数结束时变量仍被别的函数使用

* code
.code ../memory/main.go /^func main/,/^}/

* code
.code ../memory/main.go /START OMIT/,/END OMIT/

* 为什么要进行逃逸分析

- 进行逃逸分析最大程度的减少了变量内存在堆中的分配，降低了垃圾回收的次数，提高了程序执行效率

- 同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行

理解内存分配有什么用

  了解程序中变量的内存是分配在堆还是栈中，在堆中的变量何时回收，

  优化程序，减少堆变量或堆变量的回收次数，提高程序执行效率

* code(1)

.code ../slice/main.go /^func Join/,/^}/

 Join函数中的sep + slice[i] 大小不确定，会被分配到堆内存中

 由于为string是只读的，不能修改，所以每次s += sep + slice[i]赋值s之后之前的sep + slice[i]就会回收

 造成了i-1次垃圾回收和堆内存分配

* 性能测试代码(1)

.code ../slice/main_test.go /^func BenchmarkJoin/,/^}/

* code(2)

.code ../slice/main.go /^func FastJoin/,/^}/

 FastJoin使用[]byte类型保存连接的字符，只有在函数结束之后才会被回收，所以只有一次垃圾回收,提高了效率

* 性能测试代码(2)

.code ../slice/main_test.go /^func BenchmarkFastJoin/,/^}/

* 性能分析结果

.image join.png _ 1000

* 常量

什么是常量：

  常量的值是在编译时就确定的且不能改变的,常量的类型一般是基本类型

常量的声明

  const name Type = expression

  类型可以省略，如果省略就由右侧的表达式推断

  常量的逻辑、算数、比较运算的结果也是常量

常量与变量的区别

  常量的值在编译时就确定了且运行时不会发生改变

  常量的值必须在编译时确定，所以不能使用自定义函数给常量赋值，但是可以使用go内置函数len、cap、real等给常量赋值

* iota常量生成器

  iota:给一组有相似规则的常量赋值，iota的值从0开始，然后每一个申明的常量行加一

无类型常量：

  常量声明时没有指明类型，且通过数字字面量赋值，类型是无类型的常量

  常量通过推迟这种常量的类型确定提高了常量运算精度和值范围

* 类型

什么是类型：

  变量的类型描述了对应值可能有的属性特征,如占用的内存大小、具有的操作和运算、具有的属性和行为方法

类型的作用

  保证了程序的安全，使用类型使得编译器侦查无意义或无效的代码

  有了类型使得编译器可以进行静态类型检查和优化代码

  定义类型名称提高了代码的可读性

  类型允许程序设计者对程序以较高层次的方式思考，抽象化

类型声明格式：

  type name Type(基础类型)

  重新定义以Type类型为基础类类型的类型的真正含义
  基础类型相同的类之间可以类型转换

* code
.code ../type/main.go

* 作用域

作用域：

  指变量或常量的可以使用的范围,是编译时的概念

如何判断代码的作用域

  go内部声明的函数做作用域是整个程序都可见

  包级别的声明作用域是整个包

  导入的包作用域是导入的文件

  函数内声明的包作用域是整个函数

  for、if、switch词法块内声明的包作用域是整个词法块

* 垃圾回收器如何确定何时回收变量

什么是垃圾回收：

  一种管理动态内存的机制，负责追踪堆内存的申请、回收不再使用的堆内存和保护正在使用的堆内存。

go gc的实现原理
go gc的优势
go 程序性能的调优

* 基本数据类型
go中的数据类型：

  基础数据类型、聚合类型、引用类型、接口类型

基础数据类型：

  整数、浮点数、复数、布尔值和字符串

* 整数

整数的类型：

  无符号整数和有符号整数

无符号整数类型：

  无符号类型有uint8、uint16、uint32、uint64、uint和uintptr

  无符号类型的范围是0到2的n次方−1

  byte类型是uint8的别名

  uint的大小与平台相关，不是是32位就是64位，但是具体大小有平台决定

  uintptr是用来存放指针值值得类型，大小与平台有关

* 有符号整数类型

  有符号整数类型有int8、int16、int32、int64和int

  有符号整数的范围是-2的n-1次方到2的n-1次方-1

  rune类型是int32的别名，指明值是Unicode码点的值

  int类型的大小与平台有关，不是32位就是64位，具体有平台决定

* code
.code ../integer/main.go /START MIT/,/END MIT/

* 运行得出范围值结果
.image integer.png _ 1000

* 有符号整数是如何存储的

  有符号整数采用补码的形式存储在计算机中

  最高位为符号位

什么是补码

  正数的补码等于原码；负数的补码等于反码加1，而反码等于原码符号位不变，其余各位取反

有符号整数为什么要采用补码形式存储
    
  简化计算机基本运算电路，使加减法都只需要用加法电路实现，用加法替代减法。

  简化计算机的运算

* code
.code ../int/main.go /^func main/,/}/

* 无符号整数与有符号整数的去别，分别适合在什么场合下使用
  
  无符号整数类型只能表示非负数

  同样位数的无符号数表示的整数范围比有符号整数大很多

  通常情况下大多使用有符号整数类型变量来存储整数值

  无符号类型往往只用于位运算和特定算数运算，如实现位集，解析出二进制格式的文件，或散列和加密

* 整数支持的运算

  整数可以进行算数运算、逻辑运算和比较运算

<<<<<<< HEAD
  进行运算时变量的类型必须相同，否则要进行显示类型转换才能在不同类型中进行运算操作
  
  位数大的类型像位数小的类型转换可能会发生溢出
||||||| merged common ancestors
  进行运算时变量的类型必须相同，否则要进行显示类型转换才能在不同类型中进行运算操作
=======
  进行运算时变量的类型必须相同，否则要进行显示类型转换才能进行运算操作
>>>>>>> what:完成float,bool类型总结

  运算的结果类型与运算的变量类型相同

  运算结果超出了类型的范围会发生溢出，溢出时高出位部分会被丢弃

整数支持的算数运算

  + - * / %

  / 操作数都为整型运算得到结果是整数类型

  % 操作只能用于整数类型

  运算的结果类型与操作的变量类型相同

<<<<<<< HEAD
* code
.code ../arithmetic/main.go /func main/,/}/

* 逻辑运算
||||||| merged common ancestors
逻辑运算
=======
* 逻辑运算
>>>>>>> what:完成float,bool类型总结

  & |  ^ &^ << >>

  ^ 用于一元运算时表示按位取反，用于二元运算时表示按位异或

  x &^ y 是按位清空，如果y上的值是0则取x对应位上的值，如果y上bit位的值为1结果位上取0

  x<<n 或 x>>n 移位运算中n必须无符号类型

  算数上x >> n结果是x除以2的n次方向下取整，x << n结果是x乘以2^n

  无符号移位都是用0填补空位

  有符号整数右移是用符号位填补空位

  有符号位左移是用0填补空位

  运算的结果类型与操作的变量类型相同

* code

.play ../logicoper/main.go

* 逻辑运算

  == != < <= > >=

  比较表达式的结果类型是布尔型

类型转换

  使用T(x)可以将x转换成T类型

  整型与整型的类型转换大部分不会发生值得变化，只是告诉编译器如何解读值

  当缩减大小的整型转换或浮点数转换会发生值得改变或精度损失


* 浮点数

  go中支持float32和float64两种类型浮点数

  float32支持的精度大约是6位

  float64支持的精度大约是15位

  因为float64能表示的范围更大，精确度更高，一般情况使用float64类型保存浮点数更多

* code
.play ../float/main.go

* 布尔值

  布尔型的值只有两种可能：真（true)和假（false）

  预算符&&或者||的运算结果是布尔类型

  比较运算的运算结果是布尔类型

* 字符串

  字符串定义：不可变字节序列

  字符串的内存结构

.image strmemory.png _ 300

  有一个保存了底层数据首字符位置的指针和保存字符占用的字节长度结构组成

  底层保存字符值的是[]byte类型保存字符值

* 字符的操作：

  s := "hello,world"

  len(s)返回字符串s的字节数

  s[i]返回第i个字节对应的字符值

  生成字符串的子串操作s[i:j]，s[i:j]返回s从i开始知道j位置的字符串值，s[i:]返回从i开始直到结尾的字符串，s[:j]返回开始直到j的字符串

  虽然可以把新值赋予字符串变量，但是字符串值本身包含的字节序列是始终不会发生改变的，所以s[i],s[i:j],s[i:]都是共用相同的底层数据

  由于字符串值本身不可变，所以可以安全的公用底层数据，使得复制字符串和生成子串都不需要新的内存，因此字符串的复制和生成子串效率都很高

  +号运算可以连接两个字符串生成新的字符串

* code

.play ../string/main.go

* 代码过程分析分析i
 
.image string.png _ 400

* 字符串字面量

字符串字面量:

  带双引号的字节序列，可以用来给字符串变量赋值

原生字符串字面量:

  带反引号``的字节序列，可以用来给字符串变量赋值

  原生字符串字面量转义序列不起作用，转义序列会直接当作字普通符处理

* Unicode

字符：

字符集：

字符码：

字符集编码：






