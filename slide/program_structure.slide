go语言基础
2019-11-28
Tags: go, kownledge base

Abby Nie

* 程序结构 fix

go语言的程序通过小的基本组件构建而来，

小的基本组件：

  变量、常量、类型和函数几种基本结构，

  由基础数据类型通过数组和结构体聚合；

  使用 if、for、switch等控制语句控制程序执行流程；

由语句组成函数隔离和复用；

函数组织成源文件，

源文件再组织成包来支持模块化；

* 命名

go语言命名的基本规则

- 包名都是小写
- 使用驼峰式命名法
- 仅首字母大写的是可导出的
- 变量或常量的作用域越大，使用越长且越有意义的名称，作用域小的局部变量尽量使用短名称
- 函数命名简短清晰

* 如何做有意义的命名

什么是有意的命名：有意义的名称能告诉你它为什么存在，有什么用和如何使用

- 命名要做有意义的区分，不要使用a1、a2这类没意义的名称，或者Info、Data这种含义很泛的名称
- 养成统一的命名风格，不要使用相近的不同单词来命名同种方法，如fetch、retrieve、get等
- 类名使用名词，方法名使用动词或动词短语
- 使用有意义的语境，并结合上下文命名

* 声明 ( 1 )

go中的声明和格式
变量:

  var 名称 类型

  名称 := 值（短声明）

常量:

  const 名称 类型

类型

  type 名称 类型

  type 名称 struct{
    属性名称 类型
  }

* 声明  ( 2 )

函数

  func 函数名称(参数名称 类型) 返回值类型

包声明

  package 包名称

导入包声明

  import 导入包的路径


* 变量

变量的声明

  var name type = expression

- 变量的声明声明了变量的名称、类型和初始化了初始值
- 变量的类型或初始化表达式可以省略，如果省略初始值变量将初始化为对应类型的零值；如果省略了类型，变量的类型将由初始化表达式决定

  name := expression
  短变量声明只适用于局部变量，不适合于包级别变量声明，变量类型由右边表达是决定

* 各种类型对应的零值

  数字类型是0

  布尔类型是false

  strings类型行是""

  接口和引用类型是nil

  像数组或者结构体这种聚合类型默认初始值是成员的的零值

go中变量默认初始化作用：

  简化了代码

  使程序不会因为变量没有初始化造成错误或不可预测的问题

  go中提倡对复杂类型变量进行有意义的初始化,使变量在生命周期开始时就是可用的

  java中没有默认初始化机制，如果变量没有默认初始化就会报错

变量的作用:

  系统分配内存给变量存储变量值

  变量通过名称区分了不同的变量

* 代码
.code ./go-review-training/initvalue/main.go

* 指针
什么是指针: 指针的值保存了变量的地址

指针的作用

  通过指针我们不需要知道变量的名字就可以读取和更新变量的值

指针声明格式

  var name *Type = expression

赋值和更新变量的值

  var x int = 125

  var p *int

  var p = &x
  *p = 2
  指针p的类型为*int类型
  通过&x获得了变量x的地址赋值给了指针p
  *p代表变量的值，通过*p=expression更新了变量的值

* code
.code ./go-review-training/pointer/main.go

* 解释
- 函数返回变量地址时，在函数运行结束后变量仍然存在
- 通过在函数中传递指针参数，在函数中可以直接更新指针所指向变量的值
- 指针在内存中的形式:
.image ./pointer.png

* new Function
  p := new(int)
  new(T)创建了匿名类型为T的变量，初始化匿名变量的值为对应类型零值，并且把它的地址返回
.code ./go-review-training/new/main.go

* 变量的赋值
赋值的格式

.code ./go-review-training/assignment/main.go

* 可赋值性

什么是可赋值的

- 在=左侧变量的类型与右侧赋值表达式的类型相同时一定是可以赋值的
- 赋值语句两侧的类型必须精确匹配
- nil可以赋值给任何接口或引用类型
- 进行== 或!=等运算符进行比较时比较运算两侧的操作数必须是可赋值的

* 变量的生命周期
什么是变量生命周期：在程序运行过程中变量存在的时间

如何判定变量的生命周期

- 全局变量的生命周期是整个程序运行时间

- 局部变量的生命周期是动态的，从声明时开始创建，直到不可访问时结束，并且变量占用的内存会被回收

- 函数中的参数和返回值也是局部变量，在其闭包函数被调用时创建,函数结束时如果没有外部引用时结束

* code
.code ./go-review-training/lifetime/main.go


* 变量的内存分配
  1.变量的内存分配既可以在堆上分配也可以在栈上分配，编译器会自动选择在栈上还是在堆上分配，分配在堆上的内存需要垃圾回收器进行回收，分配在栈上的内存在使用完之后会自动回收
  2.编译器通过逃逸分析确定变量是否分配在栈上还是堆上，发生了逃逸的对象在运行时分配在堆上，没发生逃逸在编译时能确定变量需要的内存，在编译时编译器分配在栈上；发生了逃逸则在运行时分配在堆
  3.变量在函数返回之后能够编译器能确定没有引用的变量分配在栈上，编译器不能确定或者函数结束之后仍然被引用(发生逃逸)或者被多个gorutine引用则在堆上分配
  4.局部变量需要的内存很大也将被分配在堆中
- 变量分配在堆上与栈上的区别
  1.栈上分配的内存在使用完后会自动清理，栈上内存分配更快，但是不适合需要很大内存的分配
  2.堆上分配的内存需要垃圾回收器回收，频繁的垃圾回收器回收系统开销大，效率比栈的自动回收低
- go中变量内存分配的分析方法
  1. go build -gcflags='-m -m' main.go 或者 go build -gcflags='-m -l' main.go

* 常量
* 常量与变量的区别


