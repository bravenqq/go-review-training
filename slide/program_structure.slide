go语言基础
2019-11-28
Tags: go, kownledge base

Abby Nie

* 程序结构 fix

go语言的程序通过小的基本组件构建而来，

小的基本组件：

  变量、常量、类型和函数几种基本结构，

  由基础数据类型通过数组和结构体聚合；

  使用 if、for、switch等控制语句控制程序执行流程；

由语句组成函数隔离和复用；

函数组织成源文件，

源文件再组织成包来支持模块化；

* 命名

go语言命名的基本规则

- 包名都是小写
- 使用驼峰式命名法
- 仅首字母大写的是可导出的
- 变量或常量的作用域越大，使用越长且越有意义的名称，作用域小的局部变量尽量使用短名称
- 函数命名简短清晰

* 如何做有意义的命名

什么是有意的命名：有意义的名称能告诉你它为什么存在，有什么用和如何使用

- 命名要做有意义的区分，不要使用a1、a2这类没意义的名称，或者Info、Data这种含义很泛的名称
- 养成统一的命名风格，不要使用相近的不同单词来命名同种方法，如fetch、retrieve、get等
- 类名使用名词，方法名使用动词或动词短语
- 使用有意义的语境，并结合上下文命名

* 声明 ( 1 )

go中的声明和格式
变量:

  var 名称 类型

  名称 := 值（短声明）

常量:

  const 名称 类型

类型

  type 名称 类型

  type 名称 struct{
    属性名称 类型
  }

* 声明  ( 2 )

函数

  func 函数名称(参数名称 类型) 返回值类型

包声明

  package 包名称

导入包声明

  import 导入包的路径


* 变量

变量的声明

  var name type = expression

- 变量的声明声明了变量的名称、类型和初始化了初始值
- 变量的类型或初始化表达式可以省略，如果省略初始值变量将初始化为对应类型的零值；如果省略了类型，变量的类型将由初始化表达式决定

  name := expression
  短变量声明只适用于局部变量，不适合于包级别变量声明，变量类型由右边表达是决定

* 各种类型对应的零值

  数字类型是0

  布尔类型是false

  strings类型行是""

  接口和引用类型是nil

  像数组或者结构体这种聚合类型默认初始值是成员的的零值

go中变量默认初始化作用：

  简化了代码

  使程序不会因为变量没有初始化造成错误或不可预测的问题

  go中提倡对复杂类型变量进行有意义的初始化,使变量在生命周期开始时就是可用的

  java中没有默认初始化机制，如果变量没有默认初始化就会报错

变量的作用:

  系统分配内存给变量存储变量值

  变量通过名称区分了不同的变量

  go函数中参数变量的传递都是值传递

* 代码
.code ../initvalue/main.go

* 指针
什么是指针: 指针的值保存了变量的地址

指针的作用

  通过指针我们不需要知道变量的名字就可以读取和更新变量的值

指针声明格式

  var name *Type = expression

赋值和更新变量的值

  var x int = 125

  var p *int

  var p = &x
  *p = 2
  指针p的类型为*int类型
  通过&x获得了变量x的地址赋值给了指针p
  *p代表变量的值，通过*p=expression更新了变量的值

* code
.code ../pointer/main.go

* 解释

 函数返回变量地址时，在函数运行结束后变量仍然存在
 通过在函数中传递指针参数，在函数中可以直接更新指针所指向变量的值
 指针在内存中的形式:

.image ./pointer.png
指针有什么用

 由于同一个变量可以被多个指针类型引用和修改，所以指针类型可以减少变量的复制
 通过传递指针类型参数使变量可以再多个函数之间共享

什么时候用指针类型

 当函数对变量的修改对其他函数可见时，使用指针类型
 当变量需要的内存很大时，使用指针类型可以减少内存复制

* new Function
  p := new(int)
  new(T)创建了匿名类型为T的变量，初始化匿名变量的值为对应类型零值，并且把它的地址返回
.code ../new/main.go

* 变量的赋值
赋值的格式

.code ../assignment/main.go

* 可赋值性

什么是可赋值的

- 在=左侧变量的类型与右侧赋值表达式的类型相同时一定是可以赋值的
- 赋值语句两侧的类型必须精确匹配
- nil可以赋值给任何接口或引用类型
- 进行== 或!=等运算符进行比较时比较运算两侧的操作数必须是可赋值的

* 变量的生命周期
什么是变量生命周期：在程序运行过程中变量存在的时间

如何判定变量的生命周期

- 全局变量的生命周期是整个程序运行时间

- 局部变量的生命周期是动态的，从声明时开始创建，直到不可访问时结束，并且变量占用的内存会被回收

- 函数中的参数和返回值也是局部变量，在其闭包函数被调用时创建,函数结束时如果没有外部引用时结束

* code
.code ../lifetime/main.go

* 什么是栈内存

  是一种在函数执行时创建的后进先出的内存结构
  由CPU在编译时管理这种内存的分配
  在函数执行完之后由CPU自动回收

什么是堆内存

  是一种在运行时动态分配的内存
  手动申请和释放或者由垃圾回收器回收

栈内存与堆内存的区别

- 栈内存的的分配与回收都是由CPU自动管理，不需要手动管理；堆内存的分配需要手动管理回收或使用垃圾回收器回收
- 垃圾回收器要比较耗时，所以栈内存的创建和回收的执行效率比堆要高很多
- 栈内存分配的大小有限制，超过限制大小的内存都分配在堆上
- 在堆上创建的指针变量可以在程序任何地方访问

* go中如何确定变量的内存分配在堆上还是栈上

- go在编译时尽量将函数中的局部变量分配在栈上
- 当局部变量需要的内存很大时，变量更可能分配在堆上
- 当编译时不能确定变量需要分配内存的大小时，变量分配在堆上
- 当局部变量发生了逃逸，变量分配在堆上;如果没有发生逃逸则分配在函数的栈空间上
- 如果函数的局部变量在编译时不能确定没有被其他地方引用，则分配在堆上；否则分配在函数栈空间上

go语言中内存分配的优势

 go中的内存分配是编译器通过逃逸分析决定的，不需要用户关心是如何分配的；在c语言中需要是通过malloc() or calloc()手动申请堆内存，使用free()函数释放内存。
 go中的内存分配都是尽量分配在栈上的，决定变量内存分配在栈上还是堆上不是由哪个关键字决定，而是使用逃逸分析分析析代码得出来的，所以内存分配和回收效率更高

go中变量内存分配的分析方法

  go build -gcflags='-m -m' main.go 或者 go build -gcflags='-m -l' main.go

* go中是如何进行逃逸分析的

-  什么是逃逸分析：编译器决定变量存储位置的过程
-  当函数结束之后变量的地址被return返回了
-  变量申请的栈空间过大导致逃逸
-  变量的需要的内存不确定时
-  在函数结束时变量仍被别的函数使用

* code
.code ../memory/main.go

* 为什么要进行逃逸分析

- 进行逃逸分析最大程度的减少了变量内存在堆中的分配，降低了垃圾回收的次数，提高了程序执行效率
- 同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行

理解内存分配有什么用

  了解程序中变量的内存是分配在堆还是栈中，在堆中的变量何时回收，
  优化程序，减少堆变量或堆变量的回收次数，提高程序执行效率

* code
.code ../slice/main.go

* 代码分析
 Join函数中的sep + slice[i] 大小不确定，会被分配到堆内存中
 由于为string是只读的，不能修改，所以每次s += sep + slice[i]赋值s之后之前的sep + slice[i]就会回收
 造成了i-1次垃圾回收和堆内存分配
 后面的FastJoin使用[]byte类型保存连接的字符，只有在函数结束之后才会被回收，所以只有一次垃圾回收,提高了效率

* 性能测试代码
.code ../slice/main_test.go

* 性能分析结果
.image join.png

* 常量
什么是常量：常量的值是在编译时就确定的且不能改变的,常量的类型一般是基本类型

常量的声明
  const name Type = expression

  类型可以省略，如果省略就由右侧的表达式推断
  常量的逻辑、算数、比较运算的结果也是常量

常量与变量的区别

  常量的值在编译时就确定了且运行时不会发生改变
  常量的值必须在编译时确定，所以不能使用自定义函数给常量赋值，但是可以使用go内置函数len、cap、real等给常量赋值

iota常量生成器

  iota:给一组有相似规则的常量赋值，iota的值从0开始，然后每一个申明的常量行加一

无类型常量：
  常量声明时没有指明类型，且通过数字字面量赋值，类型是无类型的常量
  常量通过推迟这种常量的类型确定提高了常量运算精度和值范围

* 类型
* 作用域

* 垃圾回收器如何确定何时回收变量
什么是垃圾回收：一种管理动态内存的机制，负责追踪堆内存的申请、回收不再使用的堆内存和保护正在使用的堆内存。

go gc的实现原理
go gc的优势
go 程序性能的调优




