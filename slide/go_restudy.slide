# golang restudy

AbbyNie

nqq@aozsky.com

Dec,30 2020

## 系统的发展

- 庞大的库和依赖链

- 网络主导

- 客户/服务器重点

- 庞大的集群

- 多核 CPU 的兴起

- 继承的问题

## 静态类型编译语言与动态类型语言的比较

- 类型安全和内存安全

- 对并发和通信的良好支持

- 高效，无延迟的垃圾收集

- 高速编译

## Why go

- 编译速度

- 高效快速的开发

- 高并发

- 分布式系统

- 多核网络硬件

## 设计原则

- 保持正交

- 保持语法的简洁，关键字很少

```
foo.Foo *myFoo = new foo.Foo(foo.FOO_INIT) //what's the problem
```

- 减少输入，尽量让语言解决问题，保持类型系统清晰，没有类型层次结构（是指继承吗？）

## 怎么做到

- 基本原理（Fundamentals）

1. 简洁的语法

2. 轻量型类型系统

3. 没有隐式转换：保持明确

4. 无类型的未调整大小的常数：不再为 0x80ULL

5. 严格分离接口和实现

- 运行时（Run-time）

1. 垃圾收集

2. Strings, maps, communication channels. ？

3. 并发（Concurrency）

- Package model

1. 明确的依赖关系可加快构建速度（可加快编译和链接速度），构建速度取决于包管理机制 ？

### 设计方法

1. 依赖项管理

```
If A.go depends on B.go depends on C.go:
- compile C.go, B.go, then A.go.
- to compile A.go, compiler reads B.o not C.o.
```

2. 并发

- 语言负责 goroutine 管理，
  内存管理

- 不断增长的堆栈，自动完成将 goroutine 复用到
  线程

-

## 编译优化

### C 语言编译过程

```
1.
源代码------预处理---->预处理文件---compile------>汇编代码--------汇编----->机器码-----link------>可执行文件

```
