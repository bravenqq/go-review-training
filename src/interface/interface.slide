understating interface in go

Tags:go,interface

nqq

* 接口合约

 接口是对其他类型行为的抽象和概括,通过接口抽象方式能让我们设计出更加灵活和就有使用能力的程序结构

 Go语言中接口类型的独特之处在于它是满足隐式实现的,这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义

* 接口类型
  
  一系列方法的集合，实现了这些方法的具体类型是接口的实例

.code ./ex1
  
go接口的特点：

- 一般单接口命名，一个接口包含一个方法

- 接口可以组合已有的接口成新的接口类型

.code ./ex2

* 实现接口条件

  go中实现接口的规则非常简单，只要类型实现了接口中的所有方法，那么这个类型就实现了接口

  在方法的实现中，*T类型实现的接口，只能将指针类型赋值给接口变量

.code ./ex3

* interface{}接口类型

- interface{}是空接口类型，对实现它的类型没有任何要求

- 可以将任意一个值赋给空接口类型

* 接口值

- 动态类型:在go语言中类型是编译期的概念，在我们的概念模型中，一些提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符

- 动态值:实现接口的类型的实例，如var w io.Writer;w=os.Stdout中的w接口的动态值就是指os.Stdout
  
  在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil,调用一个接口的任意方法都会产生panic

.code ./ex5

  一个包含nil指针的接口不是nil接口

* 接口的比较
  
  接口比较的是接口值，两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:

.code ./ex6

* 类型断言

格式：x.(T)

- 如果T是某个类型，断言x接口的动态类型是否和T相同，相同返回动态值，否则panic

- 相反地断言的类型T是一个接口类型，然后类型断言检查是否x的动态类型满足T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值

.code ./ex7

对一个接口值的动态类型我们是不确定的，并且我们更愿意去检验它是否是一些特定的类型。如果类型断言出现在一个预期有两个结果的赋值操作中，这个操作不会在失败的时候发生panic，但是替代地返回一个额外的第二个结果，这个结果是一个标识成功与否的布尔值


* 类型分支

接口被以两种不同的方式使用。在第一个方式中，以io.Reader，io.Writer，fmt.Stringer，sort.Interface，http.Handler和error为典型，一个接口的方法表达了实现这个接口的具体类型间的相似性，但是隐藏了代码的细节和这些具体类型本身的操作。重点在于方法上，而不是具体的类型上。

第二个方式是利用一个接口值可以持有各种具体类型值的能力，将这个接口认为是这些类型的联合。类型断言用来动态地区别这些类型，使得对每一种情况都不一样。在这个方式中，重点在于具体的类型满足这个接口，而不在于接口的方法（如果它确实有一些的话），并且没有任何的信息隐藏。我们将以这种方式使用的接口描述为discriminated unions（可辨识联合）

.code ./ex8


