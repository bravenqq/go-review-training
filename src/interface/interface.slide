understating interface in go

Tags:go,interface

nqq

* 接口合约

 接口是对其他类型行为的抽象和概括,通过接口抽象方式能让我们设计出更加灵活和就有使用能力的程序结构

 Go语言中接口类型的独特之处在于它是满足隐式实现的,这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义

* 接口类型
  
  一系列方法的集合，实现了这些方法的具体类型是接口的实例

.code ./ex1
  
go接口的特点：

- 一般单接口命名，一个接口包含一个方法

- 接口可以组合已有的接口成新的接口类型

.code ./ex2

* 实现接口条件

  go中实现接口的规则非常简单，只要类型实现了接口中的所有方法，那么这个类型就实现了接口

  在方法的实现中，*T类型实现的接口，只能将指针类型赋值给接口变量

.code ./ex3

* interface{}接口类型

- interface{}是空接口类型，对实现它的类型没有任何要求

- 可以将任意一个值赋给空接口类型

* 接口值

- 动态类型:在go语言中类型是编译期的概念，在我们的概念模型中，一些提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符

- 动态值:实现接口的类型的实例，如var w io.Writer;w=os.Stdout中的w接口的动态值就是指os.Stdout
  
  在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil,调用一个接口的任意方法都会产生panic

.code ./ex5

  一个包含nil指针的接口不是nil接口

* 接口的比较
  
  接口比较的是接口值，两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:

.code ./ex6

* 类型断言
* 类型分支
* error接口
